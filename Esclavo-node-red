#include <WiFi.h>
#include <esp_now.h>
#include "esp_wifi.h"
#include "DHT.h"

// ==== CONFIGURACIÃ“N DEL SENSOR Y BUZZER ====
#define DHTPIN 4
#define DHTTYPE DHT11
#define BUZZER_PIN 23
DHT dht(DHTPIN, DHTTYPE);

// ==== MAC DEL MAESTRO ====
uint8_t masterAddress[] = {0x0C, 0x8B, 0x95, 0x1F, 0x9E, 0xD4};

// ==== ESTRUCTURA DE DATOS ====
typedef struct __attribute__((packed)) {
  float temperature;
  float humidity;
  uint8_t buzzerState;
} struct_message;

struct_message outgoingData;

// ==== VARIABLES DE SINCRONIZACIÃ“N ====
uint8_t ackCode = 200;        // ACK que confirma sincronizaciÃ³n
uint8_t currentChannel = 1;   // Canal inicial temporal
bool channelSynced = false;
unsigned long lastSend = 0;
unsigned long lastSyncAttempt = 0;
unsigned long lastChannelCheck = 0;

const unsigned long sendInterval = 3000;  // cada 3 s envÃ­a datos
const unsigned long syncTimeout   = 5000; // cada 5 s reintenta sincronizar
const unsigned long channelCheckInterval = 2000; // cada 2 s revisar canal

// ==== FUNCIONES AUXILIARES ====
void printMAC() {
  uint8_t mac[6];
  esp_wifi_get_mac(WIFI_IF_STA, mac);
  Serial.printf("ðŸ“¶ MAC del esclavo: %02X:%02X:%02X:%02X:%02X:%02X\n",
                mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
}

// ==== CAMBIAR CANAL ====
void cambiarCanal(uint8_t newChannel) {
  if (newChannel != currentChannel) {
    Serial.printf("ðŸ”„ Cambiando canal de %d â†’ %d\n", currentChannel, newChannel);
    currentChannel = newChannel;
    esp_wifi_set_channel(currentChannel, WIFI_SECOND_CHAN_NONE);
    delay(50);

    // Reconfigurar peer
    esp_now_del_peer(masterAddress);
    esp_now_peer_info_t peerInfo = {};
    memcpy(peerInfo.peer_addr, masterAddress, 6);
    peerInfo.channel = currentChannel;
    peerInfo.ifidx = WIFI_IF_STA;
    peerInfo.encrypt = false;
    esp_now_add_peer(&peerInfo);

    Serial.printf("ðŸ“¡ Canal actualizado: %d\n", currentChannel);

    // Enviar ACK al maestro
    esp_err_t result = esp_now_send(masterAddress, &ackCode, sizeof(ackCode));
    if (result == ESP_OK) Serial.println("âœ… ACK de canal enviado");
    else Serial.println("âŒ Error enviando ACK");
  }
}

// ==== CALLBACK RECEPCIÃ“N ====
void OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *data, int len) {
  // Canal del maestro
  if (len == sizeof(uint8_t)) {
    uint8_t newChannel = data[0];
    if (!channelSynced || currentChannel != newChannel) {
      Serial.printf("ðŸ“¡ Canal recibido del maestro: %d\n", newChannel);
      cambiarCanal(newChannel);
      channelSynced = true;
    }
    return;
  }

  // Comando buzzer
  if (len == sizeof(uint8_t)) {
    uint8_t buzzerCmd = data[0];
    digitalWrite(BUZZER_PIN, buzzerCmd ? HIGH : LOW);
    outgoingData.buzzerState = buzzerCmd;
    Serial.printf("ðŸ”” Buzzer %s\n", buzzerCmd ? "ON" : "OFF");
  }
}

// ==== CALLBACK ENVÃO ====
void OnDataSent(const wifi_tx_info_t *info, esp_now_send_status_t status) {
  if (status == ESP_NOW_SEND_SUCCESS)
    Serial.println("ðŸ“¤ Datos enviados correctamente");
  else
    Serial.println("âŒ Error al enviar datos");
}

// ==== REINICIAR ESP-NOW ====
void reiniciarESPNOW() {
  Serial.println("â™»ï¸ Reiniciando ESP-NOW...");
  esp_now_deinit();
  delay(50);

  if (esp_now_init() == ESP_OK) {
    esp_now_register_recv_cb(OnDataRecv);
    esp_now_register_send_cb(OnDataSent);

    esp_now_peer_info_t peerInfo = {};
    memcpy(peerInfo.peer_addr, masterAddress, 6);
    peerInfo.channel = currentChannel;
    peerInfo.ifidx = WIFI_IF_STA;
    peerInfo.encrypt = false;
    esp_now_add_peer(&peerInfo);

    Serial.printf("âœ… ESP-NOW reconfigurado en canal %d\n", currentChannel);
  } else {
    Serial.println("âŒ Error reiniciando ESP-NOW");
  }
}

// ==== SETUP ====
void setup() {
  Serial.begin(115200);
  Serial.println("ðŸš€ Iniciando ESP32 Esclavo robusto");

  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
  dht.begin();

  WiFi.mode(WIFI_STA);
  delay(50);
  printMAC();

  if (esp_now_init() != ESP_OK) {
    Serial.println("âŒ Error inicializando ESP-NOW");
    ESP.restart();
  }

  esp_now_register_recv_cb(OnDataRecv);
  esp_now_register_send_cb(OnDataSent);

  esp_now_peer_info_t peerInfo = {};
  memcpy(peerInfo.peer_addr, masterAddress, 6);
  peerInfo.channel = currentChannel;
  peerInfo.ifidx = WIFI_IF_STA;
  peerInfo.encrypt = false;
  esp_now_add_peer(&peerInfo);

  Serial.println("âœ… Esclavo listo, esperando sincronizaciÃ³n...");
  lastSyncAttempt = millis();
}

// ==== LOOP ====
void loop() {
  unsigned long now = millis();

  // ðŸ” Reintento de sincronizaciÃ³n
  if (!channelSynced && now - lastSyncAttempt > syncTimeout) {
    Serial.println("âš ï¸ Sin canal confirmado, reintentando...");
    reiniciarESPNOW();
    lastSyncAttempt = now;
  }

  // ðŸ” Enviar datos si estÃ¡ sincronizado
  if (channelSynced && now - lastSend > sendInterval) {
    lastSend = now;
    outgoingData.temperature = dht.readTemperature();
    outgoingData.humidity = dht.readHumidity();

    if (isnan(outgoingData.temperature) || isnan(outgoingData.humidity)) {
      Serial.println("âš ï¸ Error leyendo DHT11");
      return;
    }

    esp_err_t result = esp_now_send(masterAddress, (uint8_t*)&outgoingData, sizeof(outgoingData));
    if (result == ESP_OK) {
      Serial.printf("ðŸ“¡ Enviando -> T: %.1fÂ°C | H: %.1f%% | B: %d | Canal: %d\n",
                    outgoingData.temperature, outgoingData.humidity,
                    outgoingData.buzzerState, currentChannel);
    } else {
      Serial.println("âŒ Error al enviar datos, forzando resync...");
      channelSynced = false;
    }
  }

  // ðŸ” Detectar cambio de canal WiFi y forzar resync
  if (now - lastChannelCheck > channelCheckInterval) {
    lastChannelCheck = now;
    int ch = WiFi.channel();
    if (ch != currentChannel) {
      Serial.printf("ðŸ”„ Cambio de canal WiFi detectado: %d â†’ %d\n", currentChannel, ch);
      channelSynced = false;  // Forzar resync
    }
  }

  delay(50);
}
