/*
  ğŸ“¡ ComunicaciÃ³n Maestro-Esclavo con ESP32 usando ESP-NOW + ACK
  --------------------------------------------------------------
  ğŸ”§ VersiÃ³n simulada ESCLAVO (sin sensores reales)
  âœ… EnvÃ­a datos aleatorios de temperatura y humedad
  âœ… Recibe comandos ON/OFF para el buzzer
  âœ… Implementa reintentos hasta recibir ACK
*/

#include <WiFi.h>
#include <esp_now.h>
#include "esp_wifi.h"

// ==== ConfiguraciÃ³n de pines ====
#define BUZZER_PIN 23   // Pin para el buzzer

// ==== MAC del Maestro (ajusta segÃºn tu dispositivo) ====
uint8_t masterAddress[] = {0xCC, 0xDB, 0xA7, 0x30, 0x2E, 0x20}; 

// ==== Estructura de datos ====
typedef struct struct_message {
  float temperature;
  float humidity;
  uint8_t buzzerState;
} struct_message;

struct_message dataToSend;
uint8_t buzzerState = 0;

// ==== Variables de control ====
unsigned long lastSendTime = 0;
const unsigned long sendInterval = 5000; // Enviar cada 5 segundos
bool ackReceived = false;
const unsigned long ackTimeout = 200;
const int maxRetries = 5;

// ==== Callback: cuando recibe datos del maestro ====
void OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *incomingData, int len) {
  if (len == sizeof(uint8_t)) {
    uint8_t receivedValue = *incomingData;
    buzzerState = receivedValue;
    digitalWrite(BUZZER_PIN, buzzerState ? HIGH : LOW);
    Serial.printf("ğŸ’¡ Comando recibido del Maestro: Buzzer %s\n", buzzerState ? "ON" : "OFF");
  }
}

// ==== Callback: cuando se envÃ­an datos ====
void OnDataSent(const wifi_tx_info_t *wifi_tx_info, esp_now_send_status_t status) {
  if (status == ESP_NOW_SEND_SUCCESS)
    Serial.println("ğŸ“¤ Datos enviados correctamente");
  else
    Serial.println("âŒ Error al enviar datos");
}

// ==== Callback: cuando se recibe ACK ====
void OnAckRecv(const esp_now_recv_info_t *info, const uint8_t *incomingData, int len) {
  if (len == sizeof(uint8_t) && incomingData[0] == 1) {
    ackReceived = true;
    Serial.println("âœ… ACK recibido del maestro");
  }
}

// ==== Setup ====
void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("ğŸš€ Iniciando ESP32 Esclavo (SimulaciÃ³n)...");

  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);

  WiFi.mode(WIFI_STA);
  int channel = 6;
  esp_wifi_set_channel(channel, WIFI_SECOND_CHAN_NONE);

  if (esp_now_init() != ESP_OK) {
    Serial.println("âŒ Error inicializando ESP-NOW");
    ESP.restart();
  }

  esp_now_peer_info_t peerInfo = {};
  memcpy(peerInfo.peer_addr, masterAddress, 6);
  peerInfo.channel = channel;
  peerInfo.ifidx = WIFI_IF_STA;
  peerInfo.encrypt = false;

  esp_now_del_peer(masterAddress);
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
    Serial.println("âŒ Error al agregar peer maestro");
  }

  esp_now_register_recv_cb(OnDataRecv);
  esp_now_register_send_cb(OnDataSent);
  esp_now_register_recv_cb(OnAckRecv);

  Serial.println("âœ… Esclavo listo (modo simulaciÃ³n)");
}

// ==== Loop principal ====
void loop() {
  unsigned long currentTime = millis();

  if (currentTime - lastSendTime >= sendInterval) {
    lastSendTime = currentTime;

    // ğŸ”¹ Generar valores simulados
    float t = random(200, 350) / 10.0; // 20.0 a 35.0 Â°C
    float h = random(400, 900) / 10.0; // 40.0 a 90.0 %

    dataToSend.temperature = t;
    dataToSend.humidity = h;
    dataToSend.buzzerState = buzzerState;

    ackReceived = false;
    int retries = 0;

    while (!ackReceived && retries < maxRetries) {
      esp_err_t result = esp_now_send(masterAddress, (uint8_t *)&dataToSend, sizeof(dataToSend));

      if (result != ESP_OK)
        Serial.println("âŒ Error enviando datos");

      unsigned long startWait = millis();
      while (!ackReceived && millis() - startWait < ackTimeout) {
        delay(5);
      }

      if (!ackReceived) {
        retries++;
        Serial.printf("âš ï¸ No se recibiÃ³ ACK, reintentando (%d/%d)\n", retries, maxRetries);
      }
    }

    if (ackReceived) {
      Serial.printf("ğŸ“¤ Datos enviados -> Temp: %.1fÂ°C | Hum: %.1f%% | Buzzer: %s\n",
                    t, h, buzzerState ? "ON" : "OFF");
    } else {
      Serial.println("âŒ No se recibiÃ³ ACK tras varios intentos");
    }
  }

  delay(500);
}
